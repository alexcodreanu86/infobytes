<div class="row">
  <div class="small-12 medium-10 medium-offset-1 large-8 large-offset-2 columns">
    <% if @errors %>
      <% @errors.each do |error| %>
        <p><%= error %></p>
      <% end %>
    <% end %>
    <a id="href-display" class="href-buttons button tiny" onmousedown="showInputs()">Add Link</a>
      <div id="fields">
        <div style="display: inline-block;">
          <a id="href-adder" class="href-buttons button tiny" onmousedown="addAnchorTag()">Insert Tag</a>
        </div>
        <div style="display: inline-block;">
          <label for="link" class="href-button-inputs">Text:<input type="text" id="linkText" value=""></label>
          <label for="link" class="href-button-inputs">Link:<input type="text" id="link" value=""></label>
      </div>    
      
    <%= form_for [@sub_chapter,@paragraph] do |f|%>

      <div><p>Body:</p><br>
        <input type="hidden" name="paragraph[body]" value="" id="paragraph_body">
      </div>
      <div contenteditable="true" id="editable-div" class="editable"></div>

      <div><%= f.submit :onclick => "grabInput()"%></div>

    <% end %>

  </div>
</div>

<a class="close-reveal-modal">&#215;</a>

<script>
  // These toggle the visibility of the adding A tag buttons and input
  // (These are necessary for non-JQuery, with JQuery a partial could be brought in as a pop up)
  hideInputs = function() {
    display.style.display = 'inline-block'
    adder.style.display = 'none'
    link.parentNode.style.display = 'none'
    linkText.parentNode.style.display = 'none'
    link.value = "http://"
  }

  showInputs = function() {
    display.style.display = 'none'
    adder.style.display = 'inline-block'
    link.parentNode.style.display = 'inline-block'
    linkText.parentNode.style.display = 'inline-block'
  }

  // Adds an anchor tag inside the html code (so it is rendered as 
  // linked text in the editable div)
  addAnchorTag = function() {
    document.execCommand("InsertHTML", false, "<a href='" + link.value + "'>" + linkText.value +"</a>")
    hideInputs()
  }

  // Checks if selected text is inside of a container
  containerNodeCheck = function(node, container) {
    while (node) {
      if (node.id === container) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }

  // Transfers the contents of the div to the hidden input upon hitting submit so that
  // the form will pass the editable div content as a param
  grabInput = function() {
     document.getElementById('paragraph_body').value = editableDiv.innerHTML
   }
  
  // Stores needed elements inside varaibles:
  var display = document.getElementById('href-display')
  var adder = document.getElementById('href-adder')
  var link = document.getElementById('link')
  var linkText = document.getElementById('linkText')
  var editableDiv = document.getElementById('editable-div')
  
  // Sets href input and insert button to hidden at the start
  hideInputs()
</script>

<!-- For JQuery, bind the button Add Link on mousedown (on click removes the selection)
and popup the form with AJAX-->

<script>

var saveSelection, restoreSelection;

if (window.getSelection && document.createRange) {
    saveSelection = function(containerEl) {
        var range = window.getSelection().getRangeAt(0);
        var preSelectionRange = range.cloneRange();
        preSelectionRange.selectNodeContents(containerEl);
        preSelectionRange.setEnd(range.startContainer, range.startOffset);
        var start = preSelectionRange.toString().length;

        return {
            start: start,
            end: start + range.toString().length
        }
    };

    restoreSelection = function(containerEl, savedSel) {
        var charIndex = 0, range = document.createRange();
        range.setStart(containerEl, 0);
        range.collapse(true);
        var nodeStack = [containerEl], node, foundStart = false, stop = false;
        
        while (!stop && (node = nodeStack.pop())) {
            if (node.nodeType == 3) {
                var nextCharIndex = charIndex + node.length;
                if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {
                    range.setStart(node, savedSel.start - charIndex);
                    foundStart = true;
                }
                if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {
                    range.setEnd(node, savedSel.end - charIndex);
                    stop = true;
                }
                charIndex = nextCharIndex;
            } else {
                var i = node.childNodes.length;
                while (i--) {
                    nodeStack.push(node.childNodes[i]);
                }
            }
        }

        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    }
} else if (document.selection && document.body.createTextRange) {
    saveSelection = function(containerEl) {
        var selectedTextRange = document.selection.createRange();
        var preSelectionTextRange = document.body.createTextRange();
        preSelectionTextRange.moveToElementText(containerEl);
        preSelectionTextRange.setEndPoint("EndToStart", selectedTextRange);
        var start = preSelectionTextRange.text.length;

        return {
            start: start,
            end: start + selectedTextRange.text.length
        }
    };

    restoreSelection = function(containerEl, savedSel) {
        var textRange = document.body.createTextRange();
        textRange.moveToElementText(containerEl);
        textRange.collapse(true);
        textRange.moveEnd("character", savedSel.end);
        textRange.moveStart("character", savedSel.start);
        textRange.select();
    };
}

var savedSelection;

function doSave() {
    savedSelection = saveSelection( document.getElementById("editor") );
}

function doRestore() {
    if (savedSelection) {
        restoreSelection(document.getElementById("editor"), savedSelection);
    }
}
    
</script>